import { Octokit } from '@octokit/rest';
import type { RepoContext, PullRequest, FileChange } from '../types/index.js';
import { GITHUB_CONFIG, BOT_CONFIG } from '../config/index.js';
import { logger } from '../utils/logger.js';

export class GitHubBot {
  private octokit: Octokit;

  private botName: string;
  private botEmail: string;

  constructor() {
    this.octokit = new Octokit({
      auth: GITHUB_CONFIG.token,
    });
    this.botName = BOT_CONFIG.name;
    this.botEmail = BOT_CONFIG.email;
    logger.info(`üîå GitHubBot initialized as "${this.botName}" <${this.botEmail}>`);
    logger.info(`   ü§ñ Note: PRs will show as "${this.botName}" in titles and descriptions`);
    logger.info(`   üîë Commits use token owner's identity (set BOT_NAME/BOT_EMAIL for commit attribution)`);
  }

  /**
   * Get repository information
   */
  async getRepo(context: RepoContext) {
    logger.debug(`Fetching repo: ${context.owner}/${context.repo}`);
    
    const { data } = await this.octokit.rest.repos.get({
      owner: context.owner,
      repo: context.repo,
    });

    return data;
  }

  /**
   * Get file content from repository
   */
  async getFileContent(
    context: RepoContext,
    path: string,
    ref: string = context.defaultBranch
  ): Promise<{ content: string; sha: string } | null> {
    try {
      logger.debug(`Fetching file: ${path}@${ref}`);
      
      const { data } = await this.octokit.rest.repos.getContent({
        owner: context.owner,
        repo: context.repo,
        path,
        ref,
      });

      // Handle file content (not directory)
      if ('content' in data && !Array.isArray(data)) {
        const content = Buffer.from(data.content, 'base64').toString('utf-8');
        return {
          content,
          sha: data.sha,
        };
      }

      return null;
    } catch (error) {
      if ((error as any).status === 404) {
        return null;
      }
      throw error;
    }
  }

  /**
   * Create a new branch from the default branch
   */
  async createBranch(
    context: RepoContext,
    branchName: string
  ): Promise<string> {
    logger.info(`üåø Creating branch: ${branchName}`);

    // Get the latest commit SHA from default branch
    const { data: refData } = await this.octokit.rest.git.getRef({
      owner: context.owner,
      repo: context.repo,
      ref: `heads/${context.defaultBranch}`,
    });

    const sha = refData.object.sha;

    // Create new branch
    await this.octokit.rest.git.createRef({
      owner: context.owner,
      repo: context.repo,
      ref: `refs/heads/${branchName}`,
      sha,
    });

    logger.info(`‚úÖ Branch created: ${branchName}`);
    return branchName;
  }

  /**
   * Update a file in a branch
   */
  async updateFile(
    context: RepoContext,
    branch: string,
    change: FileChange
  ): Promise<void> {
    logger.info(`üìù Updating file: ${change.path}`);

    // Get current file SHA if it exists
    let sha: string | undefined;
    try {
      const { data } = await this.octokit.rest.repos.getContent({
        owner: context.owner,
        repo: context.repo,
        path: change.path,
        ref: branch,
      });

      if ('sha' in data && !Array.isArray(data)) {
        sha = data.sha;
      }
    } catch (error) {
      // File doesn't exist, will create new
      logger.debug(`File ${change.path} doesn't exist in ${branch}, creating new`);
    }

    // Create or update file with bot as committer
    await this.octokit.rest.repos.createOrUpdateFileContents({
      owner: context.owner,
      repo: context.repo,
      path: change.path,
      message: `[${this.botName}] Security: Update ${change.path}`,
      content: Buffer.from(change.content).toString('base64'),
      branch,
      sha,
      committer: {
        name: this.botName,
        email: this.botEmail,
      },
      author: {
        name: this.botName,
        email: this.botEmail,
      },
    });

    logger.info(`‚úÖ File updated: ${change.path}`);
  }

  /**
   * Create a pull request
   */
  async createPullRequest(
    context: RepoContext,
    branch: string,
    title: string,
    body: string
  ): Promise<PullRequest> {
    // Add bot branding to title
    const brandedTitle = title.startsWith('[bot]') || title.startsWith('[Bot]') 
      ? title 
      : `[${this.botName}] ${title}`;
    
    logger.info(`üîÄ Creating PR: ${brandedTitle}`);

    // Add bot signature to body
    const brandedBody = `${body}\n\n---\nü§ñ This PR was automatically generated by **${this.botName}**\nüîí Automated dependency security patch system`;

    const { data } = await this.octokit.rest.pulls.create({
      owner: context.owner,
      repo: context.repo,
      title: brandedTitle,
      body: brandedBody,
      head: branch,
      base: context.defaultBranch,
    });

    logger.info(`‚úÖ PR created: #${data.number} - ${data.html_url}`);
    logger.info(`   ü§ñ Authored as: ${this.botName}`);

    return {
      number: data.number,
      title: data.title,
      body: data.body || '',
      branch,
      url: data.html_url,
      state: data.state as 'open' | 'closed',
    };
  }

  /**
   * Add labels to a pull request
   */
  async addLabels(
    context: RepoContext,
    prNumber: number,
    labels: string[]
  ): Promise<void> {
    logger.debug(`üè∑Ô∏è  Adding labels to PR #${prNumber}: ${labels.join(', ')}`);

    await this.octokit.rest.issues.addLabels({
      owner: context.owner,
      repo: context.repo,
      issue_number: prNumber,
      labels,
    });
  }

  /**
   * Update package.json with new dependency version
   */
  async updatePackageJson(
    context: RepoContext,
    branch: string,
    packageName: string,
    newVersion: string
  ): Promise<void> {
    logger.info(`üì¶ Updating ${packageName} to ${newVersion}`);

    // Get current package.json
    const fileData = await this.getFileContent(context, 'package.json', branch);
    
    if (!fileData) {
      throw new Error('package.json not found in repository');
    }

    // Parse and update
    const packageJson = JSON.parse(fileData.content);
    
    if (packageJson.dependencies?.[packageName]) {
      packageJson.dependencies[packageName] = newVersion;
    } else if (packageJson.devDependencies?.[packageName]) {
      packageJson.devDependencies[packageName] = newVersion;
    } else {
      throw new Error(`Package ${packageName} not found in package.json`);
    }

    // Update file
    await this.updateFile(context, branch, {
      path: 'package.json',
      content: JSON.stringify(packageJson, null, 2) + '\n',
      sha: fileData.sha,
    });

    logger.info(`‚úÖ package.json updated`);
  }

  /**
   * Complete workflow: Create branch, update package.json, validate, create PR
   */
  async createPatchPR(
    context: RepoContext,
    packageName: string,
    newVersion: string,
    prTitle: string,
    prBody: string
  ): Promise<PullRequest> {
    const branchName = `patchops/${packageName}-${Date.now()}`;

    // Step 1: Create branch
    await this.createBranch(context, branchName);

    // Step 2: Update package.json
    await this.updatePackageJson(context, branchName, packageName, newVersion);

    // Step 3: Validate the update
    const validation = await this.validatePackageUpdate(context, branchName, packageName, newVersion);
    
    if (!validation.success) {
      logger.error(`‚ùå Validation failed: ${validation.error}`);
      throw new Error(`Package update validation failed: ${validation.error}`);
    }

    // Add validation warnings to PR body if any
    let enhancedPrBody = prBody;
    if (validation.warnings && validation.warnings.length > 0) {
      enhancedPrBody += `\n\n### ‚ö†Ô∏è Validation Warnings\n${validation.warnings.map(w => `- ${w}`).join('\n')}\n`;
    }
    enhancedPrBody += `\n### ‚úÖ Validation Status\n- Basic package validation: **PASSED**\n- Semver format: **VALID**\n- JSON syntax: **VALID**\n`;

    // Step 4: Create PR
    const pr = await this.createPullRequest(context, branchName, prTitle, enhancedPrBody);

    // Step 5: Add labels
    await this.addLabels(context, pr.number, ['security', 'dependencies', 'patchops']);

    return pr;
  }

  /**
   * Validate that the package update doesn't break the project
   */
  async validatePackageUpdate(
    context: RepoContext,
    branch: string,
    packageName: string,
    newVersion: string
  ): Promise<{ success: boolean; error?: string; warnings?: string[] }> {
    logger.info(`üß™ Validating ${packageName}@${newVersion} update...`);
    
    try {
      // Get package.json from the updated branch
      const packageJsonData = await this.getFileContent(context, 'package.json', branch);
      if (!packageJsonData) {
        return { success: false, error: 'package.json not found' };
      }

      const packageJson = JSON.parse(packageJsonData.content);
      const warnings: string[] = [];

      // Basic validation checks
      
      // 1. Check if the new version is valid semver
      if (!this.isValidSemver(newVersion)) {
        return { success: false, error: `Invalid semver version: ${newVersion}` };
      }

      // 2. Check for major version bumps (potential breaking changes)
      const currentVersion = packageJson.dependencies?.[packageName] || packageJson.devDependencies?.[packageName];
      if (currentVersion && this.isMajorVersionBump(currentVersion, newVersion)) {
        warnings.push(`Major version bump detected: ${currentVersion} ‚Üí ${newVersion} - may contain breaking changes`);
      }

      // 3. Check if package.json is valid JSON after our changes
      try {
        JSON.stringify(packageJson, null, 2);
      } catch (error) {
        return { success: false, error: 'package.json contains invalid JSON after update' };
      }

      // 4. Basic dependency conflict check
      const conflictCheck = this.checkBasicDependencyConflicts(packageJson, packageName, newVersion);
      if (!conflictCheck.success) {
        return { success: false, error: conflictCheck.error };
      }
      if (conflictCheck.warnings) {
        warnings.push(...conflictCheck.warnings);
      }

      logger.info(`‚úÖ Basic validation passed for ${packageName}@${newVersion}`);
      if (warnings.length > 0) {
        logger.warn(`‚ö†Ô∏è  Validation warnings: ${warnings.join(', ')}`);
      }

      return { success: true, warnings };

    } catch (error) {
      logger.error(`‚ùå Validation failed for ${packageName}@${newVersion}:`, error);
      return { success: false, error: `Validation error: ${(error as Error).message}` };
    }
  }

  /**
   * Check if a version string is valid semver
   */
  private isValidSemver(version: string): boolean {
    const semverRegex = /^(\d+)\.(\d+)\.(\d+)(?:-([0-9A-Za-z-]+(?:\.[0-9A-Za-z-]+)*))?(?:\+([0-9A-Za-z-]+(?:\.[0-9A-Za-z-]+)*))?$/;
    return semverRegex.test(version.replace(/^[^0-9]*/, '')); // Remove prefixes like ^, ~, >=
  }

  /**
   * Check if the version update is a major version bump
   */
  private isMajorVersionBump(currentVersion: string, newVersion: string): boolean {
    const cleanCurrent = currentVersion.replace(/^[^0-9]*/, '');
    const cleanNew = newVersion.replace(/^[^0-9]*/, '');
    
    const currentMajor = parseInt(cleanCurrent.split('.')[0], 10);
    const newMajor = parseInt(cleanNew.split('.')[0], 10);
    
    return newMajor > currentMajor;
  }

  /**
   * Basic dependency conflict checking
   */
  private checkBasicDependencyConflicts(
    packageJson: any, 
    packageName: string, 
    newVersion: string
  ): { success: boolean; error?: string; warnings?: string[] } {
    const warnings: string[] = [];

    // Check for peer dependency conflicts (basic check)
    if (packageJson.peerDependencies && packageJson.peerDependencies[packageName]) {
      const peerVersion = packageJson.peerDependencies[packageName];
      if (peerVersion !== newVersion && !peerVersion.includes('*')) {
        warnings.push(`Peer dependency version mismatch: ${packageName}@${peerVersion} vs ${newVersion}`);
      }
    }

    // Check for duplicate dependencies
    const inDeps = packageJson.dependencies && packageJson.dependencies[packageName];
    const inDevDeps = packageJson.devDependencies && packageJson.devDependencies[packageName];
    
    if (inDeps && inDevDeps) {
      warnings.push(`Package ${packageName} exists in both dependencies and devDependencies`);
    }

    return { success: true, warnings };
  }
}
