import sqlite3 from 'sqlite3';
import type { 
  VulnerabilityDatabase as IVulnerabilityDatabase,
  VulnerabilityIntelligence,
  PackageInfo,
  RepositoryMonitoring,
  ScanResult,
  CriticalHit
} from '../types/data-pipeline.js';
import { DATA_PIPELINE_CONFIG } from '../config/data-pipeline.js';
import { logger } from '../utils/logger.js';
import * as fs from 'fs';
import * as path from 'path';

export class VulnerabilityDatabase implements IVulnerabilityDatabase {
  private db: sqlite3.Database;
  private dbPath: string;

  constructor() {
    this.dbPath = DATA_PIPELINE_CONFIG.scanning.vulnerabilityDbPath;
    this.ensureDataDirectory();
    this.db = new sqlite3.Database(this.dbPath);
    this.initializeDatabase();
  }

  /**
   * Initialize database schema
   */
  private async initializeDatabase(): Promise<void> {
    logger.info(`üìä Initializing vulnerability database at ${this.dbPath}...`);

    const tables = [
      `CREATE TABLE IF NOT EXISTS vulnerabilities (
        id TEXT PRIMARY KEY,
        package_name TEXT NOT NULL,
        ecosystem TEXT NOT NULL,
        severity TEXT NOT NULL,
        cvss_score REAL,
        affected_versions TEXT NOT NULL,
        fixed_versions TEXT NOT NULL,
        description TEXT,
        reference_urls TEXT,
        source TEXT NOT NULL,
        discovered_at DATETIME NOT NULL,
        is_zero_day BOOLEAN DEFAULT 0,
        exploit_available BOOLEAN DEFAULT 0,
        is_kev BOOLEAN DEFAULT 0,
        created_at DATETIME DEFAULT CURRENT_TIMESTAMP,
        updated_at DATETIME DEFAULT CURRENT_TIMESTAMP
      )`,
      
      `CREATE TABLE IF NOT EXISTS monitored_repositories (
        repository_id TEXT PRIMARY KEY,
        owner TEXT NOT NULL,
        repo TEXT NOT NULL,
        default_branch TEXT NOT NULL,
        package_manager TEXT NOT NULL,
        manifest_path TEXT NOT NULL,
        lockfile_path TEXT,
        last_scanned DATETIME,
        scan_interval INTEGER DEFAULT 6,
        is_active BOOLEAN DEFAULT 1,
        critical_hit_count INTEGER DEFAULT 0,
        total_packages INTEGER DEFAULT 0,
        created_at DATETIME DEFAULT CURRENT_TIMESTAMP,
        updated_at DATETIME DEFAULT CURRENT_TIMESTAMP
      )`,
      
      `CREATE TABLE IF NOT EXISTS scan_results (
        id INTEGER PRIMARY KEY AUTOINCREMENT,
        repository_id TEXT NOT NULL,
        scan_started DATETIME NOT NULL,
        scan_completed DATETIME NOT NULL,
        packages_scanned INTEGER DEFAULT 0,
        vulnerabilities_found INTEGER DEFAULT 0,
        critical_hits INTEGER DEFAULT 0,
        low_priority INTEGER DEFAULT 0,
        scan_duration_ms INTEGER,
        created_at DATETIME DEFAULT CURRENT_TIMESTAMP
      )`,
      
      `CREATE TABLE IF NOT EXISTS critical_hits (
        id INTEGER PRIMARY KEY AUTOINCREMENT,
        repository_id TEXT NOT NULL,
        vulnerability_id TEXT NOT NULL,
        package_name TEXT NOT NULL,
        threat_score INTEGER NOT NULL,
        impact_level TEXT NOT NULL,
        usage_files TEXT,
        risk_factors TEXT,
        status TEXT DEFAULT 'active',
        created_at DATETIME DEFAULT CURRENT_TIMESTAMP,
        updated_at DATETIME DEFAULT CURRENT_TIMESTAMP
      )`
    ];

    const indexes = [
      `CREATE INDEX IF NOT EXISTS idx_vulnerabilities_package ON vulnerabilities(package_name, ecosystem)`,
      `CREATE INDEX IF NOT EXISTS idx_vulnerabilities_severity ON vulnerabilities(severity, cvss_score)`,
      `CREATE INDEX IF NOT EXISTS idx_vulnerabilities_zero_day ON vulnerabilities(is_zero_day, discovered_at)`,
      `CREATE INDEX IF NOT EXISTS idx_critical_hits_repo ON critical_hits(repository_id, status)`,
      `CREATE INDEX IF NOT EXISTS idx_scan_results_repo ON scan_results(repository_id, scan_completed)`
    ];

    try {
      for (const table of tables) {
        await this.runQuery(table);
      }
      
      for (const index of indexes) {
        await this.runQuery(index);
      }
      
      logger.info('‚úÖ Vulnerability database initialized successfully');
    } catch (error) {
      logger.error('‚ùå Failed to initialize vulnerability database:', error);
      throw error;
    }
  }

  /**
   * Helper method to run queries with promises
   */
  private runQuery(sql: string, params: any[] = []): Promise<void> {
    return new Promise((resolve, reject) => {
      this.db.run(sql, params, (err) => {
        if (err) reject(err);
        else resolve();
      });
    });
  }

  /**
   * Helper method to get single row
   */
  private getRow(sql: string, params: any[] = []): Promise<any> {
    return new Promise((resolve, reject) => {
      this.db.get(sql, params, (err, row) => {
        if (err) reject(err);
        else resolve(row);
      });
    });
  }

  /**
   * Helper method to get all rows
   */
  private getAllRows(sql: string, params: any[] = []): Promise<any[]> {
    return new Promise((resolve, reject) => {
      this.db.all(sql, params, (err, rows) => {
        if (err) reject(err);
        else resolve(rows || []);
      });
    });
  }

  /**
   * Save vulnerability to database
   */
  async saveVulnerability(vuln: VulnerabilityIntelligence): Promise<void> {
    try {
      await this.runQuery(`
        INSERT OR REPLACE INTO vulnerabilities (
          id, package_name, ecosystem, severity, cvss_score,
          affected_versions, fixed_versions, description, reference_urls,
          source, discovered_at, is_zero_day, exploit_available, is_kev,
          updated_at
        ) VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, CURRENT_TIMESTAMP)
      `, [
        vuln.id,
        vuln.packageName,
        vuln.ecosystem,
        vuln.severity,
        vuln.cvssScore || null,
        vuln.affectedVersions,
        vuln.fixedVersions,
        vuln.description,
        JSON.stringify(vuln.references),
        vuln.source,
        vuln.discoveredAt,
        vuln.isZeroDay ? 1 : 0,
        vuln.exploitAvailable ? 1 : 0,
        vuln.isKEV ? 1 : 0
      ]);

      logger.debug(`üíæ Saved vulnerability: ${vuln.id} for ${vuln.packageName}`);
    } catch (error) {
      logger.error(`‚ùå Failed to save vulnerability ${vuln.id}:`, error);
      throw error;
    }
  }

  /**
   * Find vulnerabilities for given packages
   */
  async findVulnerabilities(packages: PackageInfo[]): Promise<VulnerabilityIntelligence[]> {
    if (packages.length === 0) return [];

    try {
      const placeholders = packages.map(() => '(?, ?)').join(', ');
      const params = packages.flatMap(pkg => [pkg.name, pkg.ecosystem]);

      const rows = await this.getAllRows(`
        SELECT * FROM vulnerabilities 
        WHERE (package_name, ecosystem) IN (${placeholders})
        ORDER BY 
          CASE severity 
            WHEN 'critical' THEN 4 
            WHEN 'high' THEN 3 
            WHEN 'medium' THEN 2 
            ELSE 1 
          END DESC,
          cvss_score DESC,
          discovered_at DESC
      `, params);

      const vulnerabilities = rows.map(this.rowToVulnerability);
      logger.debug(`üîç Found ${vulnerabilities.length} vulnerabilities for ${packages.length} packages`);
      
      return vulnerabilities;
    } catch (error) {
      logger.error('‚ùå Failed to find vulnerabilities:', error);
      return [];
    }
  }

  /**
   * Get new vulnerabilities discovered since a given date
   */
  async getNewVulnerabilities(since: string): Promise<VulnerabilityIntelligence[]> {
    try {
      const rows = await this.getAllRows(`
        SELECT * FROM vulnerabilities 
        WHERE discovered_at > ?
        ORDER BY discovered_at DESC, severity DESC
      `, [since]);

      const vulnerabilities = rows.map(this.rowToVulnerability);
      logger.debug(`üÜï Found ${vulnerabilities.length} new vulnerabilities since ${since}`);
      
      return vulnerabilities;
    } catch (error) {
      logger.error('‚ùå Failed to get new vulnerabilities:', error);
      return [];
    }
  }

  /**
   * Update repository monitoring status
   */
  async updateRepositoryStatus(repo: RepositoryMonitoring): Promise<void> {
    try {
      await this.runQuery(`
        INSERT OR REPLACE INTO monitored_repositories (
          repository_id, owner, repo, default_branch, package_manager,
          manifest_path, lockfile_path, last_scanned, scan_interval,
          is_active, critical_hit_count, total_packages, updated_at
        ) VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, CURRENT_TIMESTAMP)
      `, [
        repo.repositoryId,
        repo.owner,
        repo.repo,
        repo.defaultBranch,
        repo.packageManager,
        repo.manifestPath,
        repo.lockfilePath || null,
        repo.lastScanned || null,
        repo.scanInterval,
        repo.isActive ? 1 : 0,
        repo.criticalHitCount,
        repo.totalPackages
      ]);

      logger.debug(`üíæ Updated repository status: ${repo.repositoryId}`);
    } catch (error) {
      logger.error(`‚ùå Failed to update repository status for ${repo.repositoryId}:`, error);
      throw error;
    }
  }

  /**
   * Get repository monitoring status
   */
  async getRepositoryStatus(repoId: string): Promise<RepositoryMonitoring | null> {
    try {
      const row = await this.getRow(`
        SELECT * FROM monitored_repositories WHERE repository_id = ?
      `, [repoId]);

      if (!row) return null;

      return {
        repositoryId: row.repository_id,
        owner: row.owner,
        repo: row.repo,
        defaultBranch: row.default_branch,
        packageManager: row.package_manager,
        manifestPath: row.manifest_path,
        lockfilePath: row.lockfile_path,
        lastScanned: row.last_scanned,
        scanInterval: row.scan_interval,
        isActive: row.is_active === 1,
        criticalHitCount: row.critical_hit_count,
        totalPackages: row.total_packages
      };
    } catch (error) {
      logger.error(`‚ùå Failed to get repository status for ${repoId}:`, error);
      return null;
    }
  }

  /**
   * Save scan results
   */
  async saveScanResult(result: ScanResult): Promise<void> {
    try {
      const scanDuration = new Date(result.scanCompleted).getTime() - new Date(result.scanStarted).getTime();

      await this.runQuery(`
        INSERT INTO scan_results (
          repository_id, scan_started, scan_completed, packages_scanned,
          vulnerabilities_found, critical_hits, low_priority, scan_duration_ms
        ) VALUES (?, ?, ?, ?, ?, ?, ?, ?)
      `, [
        result.repositoryId,
        result.scanStarted,
        result.scanCompleted,
        result.packagesScanned,
        result.vulnerabilitiesFound,
        result.criticalHitsCount,
        result.lowPriority,
        scanDuration
      ]);

      logger.debug(`üíæ Saved scan result for ${result.repositoryId}`);
    } catch (error) {
      logger.error(`‚ùå Failed to save scan result for ${result.repositoryId}:`, error);
      throw error;
    }
  }

  /**
   * Save critical hits
   */
  async saveCriticalHits(repositoryId: string, criticalHits: CriticalHit[]): Promise<void> {
    try {
      // Clear existing critical hits for this repository
      await this.runQuery(`DELETE FROM critical_hits WHERE repository_id = ?`, [repositoryId]);

      // Insert new critical hits
      for (const hit of criticalHits) {
        await this.runQuery(`
          INSERT INTO critical_hits (
            repository_id, vulnerability_id, package_name, threat_score,
            impact_level, usage_files, risk_factors, status
          ) VALUES (?, ?, ?, ?, ?, ?, ?, 'active')
        `, [
          repositoryId,
          hit.vulnerability.id,
          hit.packageInfo.name,
          hit.threatScore,
          hit.impactLevel,
          JSON.stringify(hit.usage.importFiles),
          JSON.stringify(hit.evidence.riskFactors)
        ]);
      }

      logger.debug(`üíæ Saved ${criticalHits.length} critical hits for ${repositoryId}`);
    } catch (error) {
      logger.error(`‚ùå Failed to save critical hits for ${repositoryId}:`, error);
      throw error;
    }
  }

  /**
   * Get dashboard metrics
   */
  async getDashboardMetrics(): Promise<{
    activeThreats: number;
    knownExploited: number;
    awaitingAction: number;
    prsOpened: number;
    totalRepositories: number;
  }> {
    try {
      const activeThreats = await this.getRow(`SELECT COUNT(*) as count FROM critical_hits WHERE status = 'active'`);
      const knownExploited = await this.getRow(`
        SELECT COUNT(DISTINCT ch.vulnerability_id) as count 
        FROM critical_hits ch 
        JOIN vulnerabilities v ON ch.vulnerability_id = v.id 
        WHERE ch.status = 'active' AND (v.is_kev = 1 OR v.exploit_available = 1)
      `);
      const totalRepos = await this.getRow(`SELECT COUNT(*) as count FROM monitored_repositories WHERE is_active = 1`);

      return {
        activeThreats: activeThreats?.count || 0,
        knownExploited: knownExploited?.count || 0,
        awaitingAction: activeThreats?.count || 0,
        prsOpened: 0, // TODO: Track PR status
        totalRepositories: totalRepos?.count || 0
      };
    } catch (error) {
      logger.error('‚ùå Failed to get dashboard metrics:', error);
      return {
        activeThreats: 0,
        knownExploited: 0,
        awaitingAction: 0,
        prsOpened: 0,
        totalRepositories: 0
      };
    }
  }

  /**
   * Get all monitored repositories
   */
  async getMonitoredRepositories(): Promise<RepositoryMonitoring[]> {
    try {
      const rows = await this.getAllRows(`
        SELECT * FROM monitored_repositories WHERE is_active = 1
        ORDER BY critical_hit_count DESC, last_scanned ASC
      `);

      return rows.map(row => ({
        repositoryId: row.repository_id,
        owner: row.owner,
        repo: row.repo,
        defaultBranch: row.default_branch,
        packageManager: row.package_manager,
        manifestPath: row.manifest_path,
        lockfilePath: row.lockfile_path,
        lastScanned: row.last_scanned,
        scanInterval: row.scan_interval,
        isActive: row.is_active === 1,
        criticalHitCount: row.critical_hit_count,
        totalPackages: row.total_packages
      }));
    } catch (error) {
      logger.error('‚ùå Failed to get monitored repositories:', error);
      return [];
    }
  }

  /**
   * Convert database row to VulnerabilityIntelligence object
   */
  private rowToVulnerability = (row: any): VulnerabilityIntelligence => ({
    id: row.id,
    packageName: row.package_name,
    ecosystem: row.ecosystem,
    severity: row.severity,
    cvssScore: row.cvss_score,
    affectedVersions: row.affected_versions,
    fixedVersions: row.fixed_versions,
    description: row.description,
    references: JSON.parse(row.reference_urls || '[]'),
    source: row.source,
    discoveredAt: row.discovered_at,
    isZeroDay: row.is_zero_day === 1,
    exploitAvailable: row.exploit_available === 1,
    isKEV: row.is_kev === 1
  });

  /**
   * Ensure data directory exists
   */
  private ensureDataDirectory(): void {
    const dataDir = path.dirname(this.dbPath);
    if (!fs.existsSync(dataDir)) {
      fs.mkdirSync(dataDir, { recursive: true });
      logger.info(`üìÅ Created data directory: ${dataDir}`);
    }
  }

  /**
   * Close database connection
   */
  async close(): Promise<void> {
    return new Promise((resolve, reject) => {
      this.db.close((err) => {
        if (err) {
          logger.error('‚ùå Failed to close database:', err);
          reject(err);
        } else {
          logger.info('‚úÖ Database connection closed');
          resolve();
        }
      });
    });
  }
}